"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[18],{4938:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-digital-twin/chapter-2-6-sim-to-real-transfer","title":"Sim-to-Real Transfer Concepts","description":"Goal","source":"@site/docs/module-2-digital-twin/chapter-2-6-sim-to-real-transfer.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/chapter-2-6-sim-to-real-transfer","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2-digital-twin/chapter-2-6-sim-to-real-transfer","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/physical-ai-humanoid-robotics-book/tree/main/docs/module-2-digital-twin/chapter-2-6-sim-to-real-transfer.md","tags":[],"version":"current","frontMatter":{"id":"chapter-2-6-sim-to-real-transfer","title":"Sim-to-Real Transfer Concepts","sidebar_label":"Sim-to-Real Transfer"},"sidebar":"book","previous":{"title":"Collision Detection","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2-digital-twin/chapter-2-5-collision-detection"},"next":{"title":"NVIDIA Isaac Platform","permalink":"/physical-ai-humanoid-robotics-book/docs/module-3-ai-robot-brain/chapter-3-1-nvidia-isaac-platform"}}');var a=i(4848),r=i(8453);const s={id:"chapter-2-6-sim-to-real-transfer",title:"Sim-to-Real Transfer Concepts",sidebar_label:"Sim-to-Real Transfer"},o="Sim-to-Real Transfer Concepts",l={},c=[{value:"Goal",id:"goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Step-by-Step Breakdown",id:"step-by-step-breakdown",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Diagrams",id:"diagrams",level:2},{value:"Case Study",id:"case-study",level:2},{value:"References",id:"references",level:2},{value:"Review Questions",id:"review-questions",level:2},{value:"Practical Exercises",id:"practical-exercises",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"sim-to-real-transfer-concepts",children:"Sim-to-Real Transfer Concepts"})}),"\n",(0,a.jsx)(n.h2,{id:"goal",children:"Goal"}),"\n",(0,a.jsx)(n.p,{children:"Understand the principles and techniques for transferring behaviors, controllers, and algorithms developed in simulation to real humanoid robots."}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Identify the challenges in sim-to-real transfer for humanoid robots"}),"\n",(0,a.jsx)(n.li,{children:"Understand domain randomization techniques to improve transferability"}),"\n",(0,a.jsx)(n.li,{children:"Learn about system identification and model calibration methods"}),"\n",(0,a.jsx)(n.li,{children:"Implement reality gap mitigation strategies"}),"\n",(0,a.jsx)(n.li,{children:"Evaluate the effectiveness of sim-to-real transfer"}),"\n",(0,a.jsx)(n.li,{children:"Apply sim-to-real techniques to humanoid robot control"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:'Sim-to-real transfer is the process of taking controllers, behaviors, and algorithms developed in simulation and successfully deploying them on real robots. This is particularly challenging for humanoid robots due to their complex dynamics, multiple contact points, and sensitivity to modeling errors. The "reality gap" - the difference between simulated and real environments - must be carefully addressed to ensure successful transfer.'}),"\n",(0,a.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reality Gap"}),": The difference between simulated and real robot behavior"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Domain Randomization"}),": Training in varied simulation conditions to improve robustness"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"System Identification"}),": Determining real robot parameters to improve simulation accuracy"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Domain Adaptation"}),": Adjusting simulation to better match real conditions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Transfer Learning"}),": Adapting simulation-trained models for real robot use"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fine-tuning"}),": Adjusting simulation-trained controllers on the real robot"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"step-by-step-breakdown",children:"Step-by-Step Breakdown"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Reality Gap Analysis"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Identify sources of simulation errors (mass, friction, compliance, etc.)"}),"\n",(0,a.jsx)(n.li,{children:"Measure discrepancies between simulation and reality"}),"\n",(0,a.jsx)(n.li,{children:"Categorize gap sources (kinematic, dynamic, environmental)"}),"\n",(0,a.jsx)(n.li,{children:"Quantify gap impact on controller performance"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"System Identification"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Measure real robot parameters (mass, inertia, friction)"}),"\n",(0,a.jsx)(n.li,{children:"Identify actuator dynamics and limitations"}),"\n",(0,a.jsx)(n.li,{children:"Characterize sensor noise and delays"}),"\n",(0,a.jsx)(n.li,{children:"Calibrate simulation parameters to match reality"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Domain Randomization"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Randomize physical parameters during training (mass, friction, etc.)"}),"\n",(0,a.jsx)(n.li,{children:"Vary environmental conditions in simulation"}),"\n",(0,a.jsx)(n.li,{children:"Add noise to sensors and actuators"}),"\n",(0,a.jsx)(n.li,{children:"Train controllers to be robust to parameter variations"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Model Calibration"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use real robot data to refine simulation models"}),"\n",(0,a.jsx)(n.li,{children:"Implement parameter estimation algorithms"}),"\n",(0,a.jsx)(n.li,{children:"Validate simulation accuracy through experiments"}),"\n",(0,a.jsx)(n.li,{children:"Iterate between simulation and reality"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Transfer Validation"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Test controllers in simulation before real deployment"}),"\n",(0,a.jsx)(n.li,{children:"Implement safety measures for real robot testing"}),"\n",(0,a.jsx)(n.li,{children:"Gradually increase controller complexity"}),"\n",(0,a.jsx)(n.li,{children:"Monitor and record transfer performance"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Adaptation Techniques"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Implement online parameter adaptation"}),"\n",(0,a.jsx)(n.li,{children:"Use machine learning for controller tuning"}),"\n",(0,a.jsx)(n.li,{children:"Apply gain scheduling for different conditions"}),"\n",(0,a.jsx)(n.li,{children:"Implement robust control methods"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Example system identification and parameter adaptation for humanoid robot\nimport numpy as np\nfrom scipy.optimize import minimize\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom control_msgs.msg import JointTrajectoryControllerState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\n\nclass SimToRealTransfer(Node):\n    def __init__(self):\n        super().__init__('sim_to_real_transfer')\n\n        # Robot parameters to identify\n        self.robot_params = {\n            'mass': 30.0,  # Base estimate\n            'com_offset_x': 0.0,  # Center of mass offset\n            'com_offset_y': 0.0,\n            'friction_coeff': 0.1,\n            'actuator_delay': 0.01,\n        }\n\n        # Subscribe to joint states and controller states\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.controller_state_sub = self.create_subscription(\n            JointTrajectoryControllerState,\n            '/controller_state',\n            self.controller_state_callback,\n            10\n        )\n\n        # Publisher for parameter updates\n        self.param_pub = self.create_publisher(\n            JointTrajectory,\n            '/parameter_adaptation',\n            10\n        )\n\n        # Data collection for system identification\n        self.collected_data = {\n            'timestamps': [],\n            'positions': [],\n            'velocities': [],\n            'accelerations': [],\n            'torques': [],\n            'commands': []\n        }\n\n        # Timer for parameter estimation\n        self.param_estimation_timer = self.create_timer(\n            1.0,  # Every second\n            self.estimate_parameters\n        )\n\n        self.get_logger().info('Sim-to-Real Transfer node initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Collect joint state data for system identification\"\"\"\n        current_time = self.get_clock().now().nanoseconds / 1e9\n\n        # Store current state\n        self.collected_data['timestamps'].append(current_time)\n        self.collected_data['positions'].append(np.array(msg.position))\n        self.collected_data['velocities'].append(np.array(msg.velocity))\n        self.collected_data['torques'].append(np.array(msg.effort))\n\n        # Estimate accelerations from velocities (if needed)\n        if len(self.collected_data['velocities']) >= 2:\n            dt = current_time - self.collected_data['timestamps'][-2]\n            if dt > 0:\n                acc = (np.array(msg.velocity) -\n                       np.array(self.collected_data['velocities'][-2])) / dt\n                self.collected_data['accelerations'].append(acc)\n            else:\n                self.collected_data['accelerations'].append(np.zeros(len(msg.velocity)))\n\n        # Limit data storage to last 1000 samples\n        if len(self.collected_data['timestamps']) > 1000:\n            for key in self.collected_data:\n                self.collected_data[key] = self.collected_data[key][-1000:]\n\n    def controller_state_callback(self, msg):\n        \"\"\"Collect controller state data\"\"\"\n        # Store command information\n        self.collected_data['commands'].append({\n            'positions': np.array(msg.desired.positions),\n            'velocities': np.array(msg.desired.velocities),\n            'accelerations': np.array(msg.desired.accelerations)\n        })\n\n        # Limit command storage\n        if len(self.collected_data['commands']) > 1000:\n            self.collected_data['commands'] = self.collected_data['commands'][-1000:]\n\n    def estimate_parameters(self):\n        \"\"\"Estimate robot parameters from collected data\"\"\"\n        if len(self.collected_data['positions']) < 10:\n            return  # Not enough data\n\n        # Use collected data to estimate parameters\n        # This is a simplified example - real system identification is more complex\n        try:\n            # Estimate mass properties using inverse dynamics\n            estimated_params = self.inverse_dynamics_identification()\n\n            # Update internal parameter estimates\n            for param_name, new_value in estimated_params.items():\n                if param_name in self.robot_params:\n                    # Apply smoothing to parameter updates\n                    alpha = 0.1  # Learning rate\n                    old_value = self.robot_params[param_name]\n                    self.robot_params[param_name] = (\n                        alpha * new_value + (1 - alpha) * old_value\n                    )\n\n            self.get_logger().info(f'Updated parameters: {self.robot_params}')\n\n        except Exception as e:\n            self.get_logger().error(f'Parameter estimation failed: {e}')\n\n    def inverse_dynamics_identification(self):\n        \"\"\"Estimate parameters using inverse dynamics approach\"\"\"\n        # Collect recent data for identification\n        n_samples = min(50, len(self.collected_data['positions']))\n        if n_samples < 10:\n            return {}\n\n        # Extract data arrays\n        pos_data = np.array(self.collected_data['positions'][-n_samples:])\n        vel_data = np.array(self.collected_data['velocities'][-n_samples:])\n        torque_data = np.array(self.collected_data['torques'][-n_samples:])\n\n        # For simplicity, estimate mass using gravity effects\n        # In practice, this would use full inverse dynamics model\n        # and more sophisticated optimization\n\n        # Estimate average gravity effect on a joint\n        # (This is a very simplified example)\n        gravity_torque = np.mean(torque_data[:, 0])  # Assume joint 0 is affected by gravity\n        estimated_mass = abs(gravity_torque) / 9.81  # Very simplified estimate\n\n        return {\n            'mass': max(1.0, min(100.0, estimated_mass)),  # Clamp to reasonable range\n        }\n\n    def domain_randomization_callback(self):\n        \"\"\"Apply domain randomization to simulation parameters\"\"\"\n        # Randomize parameters for training\n        randomized_params = {}\n\n        for param_name, base_value in self.robot_params.items():\n            if param_name == 'mass':\n                # Randomize mass by \xb120%\n                variation = np.random.uniform(0.8, 1.2)\n                randomized_params[param_name] = base_value * variation\n            elif param_name == 'friction_coeff':\n                # Randomize friction by \xb150%\n                variation = np.random.uniform(0.5, 1.5)\n                randomized_params[param_name] = max(0.01, base_value * variation)\n            elif 'com_offset' in param_name:\n                # Randomize center of mass offset\n                variation = np.random.uniform(-0.05, 0.05)\n                randomized_params[param_name] = base_value + variation\n            else:\n                randomized_params[param_name] = base_value\n\n        return randomized_params\n\n    def evaluate_transfer_performance(self, controller_output):\n        \"\"\"Evaluate how well simulation controller works on real robot\"\"\"\n        # Monitor key performance metrics\n        metrics = {\n            'tracking_error': np.mean(np.abs(controller_output['position_error'])),\n            'stability': self.check_stability(controller_output),\n            'energy_efficiency': self.calculate_energy(controller_output),\n            'safety': self.check_safety_bounds(controller_output)\n        }\n\n        return metrics\n\n    def check_stability(self, controller_output):\n        \"\"\"Check if robot remains stable\"\"\"\n        # Check for excessive oscillations or divergence\n        if 'position_error' in controller_output:\n            error_history = controller_output['position_error']\n            if len(error_history) > 10:\n                recent_error = np.array(error_history[-10:])\n                std_error = np.std(recent_error)\n                return float(std_error < 0.5)  # Stable if std < 0.5\n        return 1.0\n\n    def calculate_energy(self, controller_output):\n        \"\"\"Calculate energy efficiency metric\"\"\"\n        if 'torques' in controller_output and 'velocities' in controller_output:\n            power = np.sum(np.abs(controller_output['torques'] *\n                                 controller_output['velocities']))\n            return 1.0 / (1.0 + power)  # Higher efficiency = lower power\n        return 0.5\n\n    def check_safety_bounds(self, controller_output):\n        \"\"\"Check if robot remains within safety bounds\"\"\"\n        # Check joint limits, velocities, accelerations\n        safety_score = 1.0\n        if 'positions' in controller_output:\n            pos = np.array(controller_output['positions'])\n            # Check if positions are within reasonable bounds\n            if np.any(np.abs(pos) > 3.0):  # Assuming reasonable joint limits\n                safety_score *= 0.5\n        return float(safety_score)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    sim_to_real_node = SimToRealTransfer()\n\n    try:\n        rclpy.spin(sim_to_real_node)\n    except KeyboardInterrupt:\n        sim_to_real_node.get_logger().info('Shutting down')\n    finally:\n        sim_to_real_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"diagrams",children:"Diagrams"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Sim-to-Real Transfer Process:\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Simulation    \u2502\u2500\u2500\u2500\u25b6\u2502  Real Robot     \u2502\u2500\u2500\u2500\u25b6\u2502  Performance    \u2502\n\u2502   Environment   \u2502    \u2502  (Hardware)     \u2502    \u2502  Evaluation     \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 \u2022 Accurate      \u2502    \u2502 \u2022 Physical      \u2502    \u2502 \u2022 Success rate  \u2502\n\u2502   Physics       \u2502    \u2502   Dynamics      \u2502    \u2502 \u2022 Error metrics \u2502\n\u2502 \u2022 Sensor        \u2502    \u2502 \u2022 Real Sensors  \u2502    \u2502 \u2022 Stability     \u2502\n\u2502   Models        \u2502    \u2502 \u2022 Actuator      \u2502    \u2502 \u2022 Efficiency    \u2502\n\u2502 \u2022 Environment   \u2502    \u2502   Limitations   \u2502    \u2502                 \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502                       \u2502                       \u2502\n        \u2502                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  Transfer   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502  Process     \u2502\n                         \u2502              \u2502\n                         \u2502 \u2022 Parameter  \u2502\n                         \u2502   Calibration\u2502\n                         \u2502 \u2022 Domain     \u2502\n                         \u2502   Random.    \u2502\n                         \u2502 \u2022 Adaptation \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReality Gap Mitigation Strategies:\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Reality Gap                          \u2502\n\u2502  (Simulation vs Real World Differences)                 \u2502\n\u2502                                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502  \u2502  Physical       \u2502    \u2502  Environmental  \u2502            \u2502\n\u2502  \u2502  Differences    \u2502    \u2502  Differences    \u2502            \u2502\n\u2502  \u2502                \u2502    \u2502                 \u2502            \u2502\n\u2502  \u2502 \u2022 Mass, inertia \u2502    \u2502 \u2022 Floor texture \u2502            \u2502\n\u2502  \u2502 \u2022 Friction      \u2502    \u2502 \u2022 Lighting      \u2502            \u2502\n\u2502  \u2502 \u2022 Compliance    \u2502    \u2502 \u2022 Objects       \u2502            \u2502\n\u2502  \u2502 \u2022 Actuator      \u2502    \u2502 \u2022 Temperature   \u2502            \u2502\n\u2502  \u2502   dynamics      \u2502    \u2502                 \u2502            \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502                                                         \u2502\n\u2502  Mitigation Strategies:                                 \u2502\n\u2502  \u2022 System Identification \u2500\u2500\u2500\u25b6 Calibrate simulation     \u2502\n\u2502  \u2022 Domain Randomization \u2500\u2500\u25b6 Robust controllers         \u2502\n\u2502  \u2022 Fine-tuning \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Adapt on real robot        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h2,{id:"case-study",children:"Case Study"}),"\n",(0,a.jsx)(n.p,{children:"The Boston Dynamics Atlas robot demonstrates successful sim-to-real transfer through sophisticated simulation models and careful reality gap mitigation. The company uses detailed physics simulation with accurate mass properties, actuator dynamics, and contact models. They employ domain randomization techniques during controller training, randomizing physical parameters to create robust controllers that work in both simulation and reality. The result is that many of Atlas's complex behaviors, including dynamic walking and parkour, are first developed and refined in simulation before being deployed on the real robot."}),"\n",(0,a.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://arxiv.org/abs/1703.06907",children:"Domain Randomization for Transferring Deep Neural Networks"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://arxiv.org/abs/1802.01568",children:"Sim-to-Real Transfer in Robotics"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-ident.pdf",children:"System Identification for Robotics"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"What are the main sources of the reality gap in humanoid robot simulation?"}),"\n",(0,a.jsx)(n.li,{children:"How does domain randomization improve sim-to-real transfer?"}),"\n",(0,a.jsx)(n.li,{children:"What role does system identification play in improving simulation accuracy?"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"practical-exercises",children:"Practical Exercises"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Implement a simple system identification routine for a single joint"}),"\n",(0,a.jsx)(n.li,{children:"Create a simulation with randomized parameters and test controller robustness"}),"\n",(0,a.jsx)(n.li,{children:"Compare controller performance in simulation vs with added noise/uncertainty"}),"\n",(0,a.jsx)(n.li,{children:"Design a parameter adaptation algorithm for a simulated humanoid"}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(6540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);