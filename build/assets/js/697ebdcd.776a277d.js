"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[691],{6439:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>t,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"module-2-digital-twin/chapter-2-5-collision-detection","title":"Collision Detection and Environment Modeling","description":"Goal","source":"@site/docs/module-2-digital-twin/chapter-2-5-collision-detection.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/chapter-2-5-collision-detection","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2-digital-twin/chapter-2-5-collision-detection","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/physical-ai-humanoid-robotics-book/tree/main/docs/module-2-digital-twin/chapter-2-5-collision-detection.md","tags":[],"version":"current","frontMatter":{"id":"chapter-2-5-collision-detection","title":"Collision Detection and Environment Modeling","sidebar_label":"Collision Detection"},"sidebar":"book","previous":{"title":"Sensor Simulation","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2-digital-twin/chapter-2-4-sensor-simulation"},"next":{"title":"Sim-to-Real Transfer","permalink":"/physical-ai-humanoid-robotics-book/docs/module-2-digital-twin/chapter-2-6-sim-to-real-transfer"}}');var l=i(4848),s=i(8453);const t={id:"chapter-2-5-collision-detection",title:"Collision Detection and Environment Modeling",sidebar_label:"Collision Detection"},r="Collision Detection and Environment Modeling",c={},a=[{value:"Goal",id:"goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Step-by-Step Breakdown",id:"step-by-step-breakdown",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Diagrams",id:"diagrams",level:2},{value:"Case Study",id:"case-study",level:2},{value:"References",id:"references",level:2},{value:"Review Questions",id:"review-questions",level:2},{value:"Practical Exercises",id:"practical-exercises",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.header,{children:(0,l.jsx)(e.h1,{id:"collision-detection-and-environment-modeling",children:"Collision Detection and Environment Modeling"})}),"\n",(0,l.jsx)(e.h2,{id:"goal",children:"Goal"}),"\n",(0,l.jsx)(e.p,{children:"Implement accurate collision detection and environment modeling for humanoid robots in simulation, ensuring realistic interaction with the environment and self-collision avoidance."}),"\n",(0,l.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Understand collision detection algorithms used in robotics simulation"}),"\n",(0,l.jsx)(e.li,{children:"Configure collision properties for humanoid robot models"}),"\n",(0,l.jsx)(e.li,{children:"Implement environment modeling for complex scenarios"}),"\n",(0,l.jsx)(e.li,{children:"Set up self-collision detection and avoidance"}),"\n",(0,l.jsx)(e.li,{children:"Understand the impact of collision detection on simulation performance"}),"\n",(0,l.jsx)(e.li,{children:"Validate collision behavior for sim-to-real transfer"}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(e.p,{children:"Collision detection is fundamental to humanoid robot simulation, enabling realistic interaction with the environment and preventing self-intersection. For humanoid robots with complex kinematic structures and many degrees of freedom, proper collision detection is essential for stable simulation and accurate behavior prediction. This includes modeling the robot's collision geometry, environment obstacles, and implementing efficient detection algorithms."}),"\n",(0,l.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Collision Geometry"}),": Simplified shapes used for collision detection (boxes, spheres, meshes)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Broad Phase Detection"}),": Fast algorithms to identify potentially colliding pairs"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Narrow Phase Detection"}),": Precise algorithms to determine actual collisions"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Contact Manifolds"}),": Information about collision points and forces"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Self-Collision"}),": Collision detection between different parts of the same robot"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Environment Collision"}),": Collision detection with world objects"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Collision Response"}),": How the physics engine handles collisions"]}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"step-by-step-breakdown",children:"Step-by-Step Breakdown"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Collision Geometry Design"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Choose appropriate collision shapes for each link"}),"\n",(0,l.jsx)(e.li,{children:"Balance accuracy vs performance with simplified geometries"}),"\n",(0,l.jsx)(e.li,{children:"Consider different geometries for different purposes"}),"\n",(0,l.jsx)(e.li,{children:"Optimize collision meshes for humanoid-specific interactions"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Broad Phase Algorithms"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Understand spatial partitioning methods (octrees, bounding volume hierarchies)"}),"\n",(0,l.jsx)(e.li,{children:"Configure collision detection parameters"}),"\n",(0,l.jsx)(e.li,{children:"Understand the trade-offs between different broad phase methods"}),"\n",(0,l.jsx)(e.li,{children:"Optimize for humanoid robot's specific kinematic structure"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Narrow Phase Implementation"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Understand GJK, EPA, and other collision detection algorithms"}),"\n",(0,l.jsx)(e.li,{children:"Configure collision response parameters"}),"\n",(0,l.jsx)(e.li,{children:"Set up contact point generation"}),"\n",(0,l.jsx)(e.li,{children:"Handle special cases (mesh-mesh collisions)"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Self-Collision Configuration"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Define which robot parts can collide with each other"}),"\n",(0,l.jsx)(e.li,{children:"Set up collision masks to ignore certain pairs"}),"\n",(0,l.jsx)(e.li,{children:"Configure self-collision detection for safety"}),"\n",(0,l.jsx)(e.li,{children:"Optimize performance for many-joint robots"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Environment Modeling"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Create collision models for environment objects"}),"\n",(0,l.jsx)(e.li,{children:"Configure static vs dynamic collision objects"}),"\n",(0,l.jsx)(e.li,{children:"Set up complex environments with multiple obstacles"}),"\n",(0,l.jsx)(e.li,{children:"Implement level-of-detail for performance"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Performance Optimization"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Balance accuracy and performance requirements"}),"\n",(0,l.jsx)(e.li,{children:"Configure collision detection frequency"}),"\n",(0,l.jsx)(e.li,{children:"Use appropriate collision shapes for performance"}),"\n",(0,l.jsx)(e.li,{children:"Understand the impact of collision complexity on simulation speed"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example SDF with collision detection configuration for humanoid robot --\x3e\n<sdf version="1.7">\n  <model name="humanoid_collision_model">\n    <link name="torso">\n      <pose>0 0 0 0 0 0</pose>\n      <inertial>\n        <mass>10.0</mass>\n        <inertia>\n          <ixx>0.3</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>0.4</iyy>\n          <iyz>0.0</iyz>\n          <izz>0.2</izz>\n        </inertia>\n      </inertial>\n\n      \x3c!-- Visual geometry --\x3e\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.3 0.2 0.5</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.5 0.5 0.5 1</ambient>\n          <diffuse>0.7 0.7 0.7 1</diffuse>\n        </material>\n      </visual>\n\n      \x3c!-- Collision geometry (simplified for performance) --\x3e\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.3 0.2 0.5</size>\n          </box>\n        </geometry>\n        <surface>\n          <contact>\n            <ode>\n              <soft_cfm>0.001</soft_cfm>\n              <soft_erp>0.8</soft_erp>\n              <kp>1e+5</kp>\n              <kd>1.0</kd>\n              <max_vel>100.0</max_vel>\n              <min_depth>0.001</min_depth>\n            </ode>\n          </contact>\n          <friction>\n            <ode>\n              <mu>0.5</mu>\n              <mu2>0.5</mu2>\n            </ode>\n          </friction>\n          <bounce>\n            <restitution_coefficient>0.01</restitution_coefficient>\n            <threshold>100000</threshold>\n          </bounce>\n        </surface>\n      </collision>\n    </link>\n\n    <link name="left_arm_upper">\n      <pose>0.2 0.15 -0.1 0 0 0</pose>\n      <inertial>\n        <mass>2.0</mass>\n        <inertia>\n          <ixx>0.05</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>0.05</iyy>\n          <iyz>0.0</iyz>\n          <izz>0.01</izz>\n        </inertia>\n      </inertial>\n\n      <visual name="visual">\n        <geometry>\n          <cylinder>\n            <radius>0.05</radius>\n            <length>0.3</length>\n          </cylinder>\n        </geometry>\n      </visual>\n\n      <collision name="collision">\n        <geometry>\n          <cylinder>\n            <radius>0.05</radius>\n            <length>0.3</length>\n          </cylinder>\n        </geometry>\n        <surface>\n          <contact>\n            <ode>\n              <soft_cfm>0.001</soft_cfm>\n              <soft_erp>0.8</soft_erp>\n              <kp>1e+5</kp>\n              <kd>1.0</kd>\n              <max_vel>100.0</max_vel>\n              <min_depth>0.001</min_depth>\n            </ode>\n          </contact>\n        </surface>\n      </collision>\n    </link>\n\n    <link name="left_arm_lower">\n      <pose>0.2 0.15 -0.4 0 0 0</pose>\n      <inertial>\n        <mass>1.5</mass>\n        <inertia>\n          <ixx>0.03</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>0.03</iyy>\n          <iyz>0.0</iyz>\n          <izz>0.01</izz>\n        </inertia>\n      </inertial>\n\n      <visual name="visual">\n        <geometry>\n          <cylinder>\n            <radius>0.04</radius>\n            <length>0.25</length>\n          </cylinder>\n        </geometry>\n      </visual>\n\n      <collision name="collision">\n        <geometry>\n          <cylinder>\n            <radius>0.04</radius>\n            <length>0.25</length>\n          </cylinder>\n        </geometry>\n        <surface>\n          <contact>\n            <ode>\n              <soft_cfm>0.001</soft_cfm>\n              <soft_erp>0.8</soft_erp>\n              <kp>1e+5</kp>\n              <kd>1.0</kd>\n              <max_vel>100.0</max_vel>\n              <min_depth>0.001</min_depth>\n            </ode>\n          </contact>\n        </surface>\n      </collision>\n    </link>\n\n    \x3c!-- Joint with collision exclusion --\x3e\n    <joint name="left_shoulder" type="revolute">\n      <parent>torso</parent>\n      <child>left_arm_upper</child>\n      <axis>\n        <xyz>0 0 1</xyz>\n        <limit>\n          <lower>-1.57</lower>\n          <upper>1.57</upper>\n          <effort>50</effort>\n          <velocity>2</velocity>\n        </limit>\n      </axis>\n    </joint>\n\n    <joint name="left_elbow" type="revolute">\n      <parent>left_arm_upper</parent>\n      <child>left_arm_lower</child>\n      <axis>\n        <xyz>0 1 0</xyz>\n        <limit>\n          <lower>0</lower>\n          <upper>2.0</upper>\n          <effort>30</effort>\n          <velocity>2</velocity>\n        </limit>\n      </axis>\n    </joint>\n\n    \x3c!-- Self-collision exclusion (for adjacent links) --\x3e\n    <joint name="left_shoulder_collision_exclude" type="fixed">\n      <parent>left_arm_upper</parent>\n      <child>torso</child>\n      <physics>\n        <ode>\n          <provide_feedback>false</provide_feedback>\n        </ode>\n      </physics>\n    </joint>\n  </model>\n\n  \x3c!-- Environment with complex collision geometry --\x3e\n  <model name="obstacle_environment">\n    <static>true</static>\n\n    \x3c!-- Complex obstacle with detailed collision mesh --\x3e\n    <link name="complex_obstacle">\n      <collision name="collision">\n        <geometry>\n          <mesh>\n            <uri>model://environment/meshes/complex_obstacle.dae</uri>\n            <scale>1.0 1.0 1.0</scale>\n          </mesh>\n        </geometry>\n        <surface>\n          <contact>\n            <ode>\n              <soft_cfm>0.001</soft_cfm>\n              <soft_erp>0.8</soft_erp>\n              <kp>1e+6</kp>\n              <kd>10.0</kd>\n              <max_vel>100.0</max_vel>\n              <min_depth>0.001</min_depth>\n            </ode>\n          </contact>\n          <friction>\n            <ode>\n              <mu>0.8</mu>\n              <mu2>0.8</mu2>\n            </ode>\n          </friction>\n        </surface>\n      </collision>\n\n      <visual name="visual">\n        <geometry>\n          <mesh>\n            <uri>model://environment/meshes/complex_obstacle.dae</uri>\n            <scale>1.0 1.0 1.0</scale>\n          </mesh>\n        </geometry>\n      </visual>\n    </link>\n  </model>\n</sdf>\n'})}),"\n",(0,l.jsx)(e.h2,{id:"diagrams",children:"Diagrams"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{children:"Collision Detection Hierarchy:\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Broad Phase                           \u2502\n\u2502  (Quick elimination of non-colliding pairs)            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502   AABB Tree \u2502  \u2502   Octree    \u2502  \u2502   Grid      \u2502    \u2502\n\u2502  \u2502   (Boxes)   \u2502  \u2502   Spatial   \u2502  \u2502   Spatial   \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Narrow Phase                          \u2502\n\u2502  (Precise collision detection)                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502   GJK       \u2502  \u2502   EPA       \u2502  \u2502   SAT       \u2502    \u2502\n\u2502  \u2502  (Convex)   \u2502  \u2502  (Penetration\u2502  \u2502  (Separating\u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   Depth)    \u2502  \u2502   Axes)     \u2502    \u2502\n\u2502                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Contact Generation                       \u2502\n\u2502  (Collision points, normals, forces)                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502  Contact    \u2502  \u2502  Friction   \u2502  \u2502  Response   \u2502    \u2502\n\u2502  \u2502  Points     \u2502  \u2502  Model      \u2502  \u2502  Model      \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSelf-Collision Management:\n\nHumanoid Robot Structure:\n  Torso\n  \u251c\u2500\u2500 Head\n  \u251c\u2500\u2500 Left Arm\n  \u2502   \u251c\u2500\u2500 Upper Arm\n  \u2502   \u2514\u2500\u2500 Lower Arm\n  \u251c\u2500\u2500 Right Arm\n  \u2502   \u251c\u2500\u2500 Upper Arm\n  \u2502   \u2514\u2500\u2500 Lower Arm\n  \u251c\u2500\u2500 Left Leg\n  \u2502   \u251c\u2500\u2500 Upper Leg\n  \u2502   \u251c\u2500\u2500 Lower Leg\n  \u2502   \u2514\u2500\u2500 Foot\n  \u2514\u2500\u2500 Right Leg\n      \u251c\u2500\u2500 Upper Leg\n      \u251c\u2500\u2500 Lower Leg\n      \u2514\u2500\u2500 Foot\n\nCollision Pairs to Consider:\n  \u2713 Torso \u2194 Arms (when arms cross)\n  \u2713 Arms \u2194 Legs (during movement)\n  \u2713 Feet \u2194 Ground\n  \u2717 Adjacent links (elbow joint parts) - typically excluded\n  \u2713 End effectors \u2194 Environment\n\nPerformance vs Accuracy Trade-off:\n\nHigh Accuracy \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf Real Robot\n              \u2571                                     \u2571 \u2502\n            \u2571                                     \u2571   \u2502\n          \u2571                                     \u2571     \u2502\n        \u2571                                     \u2571       \u2502\n      \u2571                                     \u2571         \u2502\n    \u2571                                     \u2571           \u2502\n  \u2571                                     \u2571             \u2502\nLow Accuracy \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf               \u2502\n                Low Performance    High Performance\n"})}),"\n",(0,l.jsx)(e.h2,{id:"case-study",children:"Case Study"}),"\n",(0,l.jsx)(e.p,{children:"The Atlas humanoid robot simulation includes sophisticated collision detection to handle its complex 28-DOF structure. The simulation uses simplified collision geometries for performance while maintaining accuracy in critical areas like the feet for balance control. Researchers have found that proper collision detection is essential for stable walking simulation, as incorrect collision behavior can lead to unrealistic gait patterns that don't transfer to the real robot."}),"\n",(0,l.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"http://gazebosim.org/tutorials?tut=collision&cat=physics",children:"Gazebo Collision Detection Documentation"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"https://pybullet.org/wordpress/",children:"Bullet Physics Collision Detection"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"https://www.ode.org/",children:"ODE Collision Detection"})}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"What is the difference between broad phase and narrow phase collision detection?"}),"\n",(0,l.jsx)(e.li,{children:"Why is self-collision detection important for humanoid robots?"}),"\n",(0,l.jsx)(e.li,{children:"How do collision geometry simplifications affect simulation performance?"}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"practical-exercises",children:"Practical Exercises"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"Create a simple humanoid model with collision geometry"}),"\n",(0,l.jsx)(e.li,{children:"Implement a collision detection test between robot and environment"}),"\n",(0,l.jsx)(e.li,{children:"Configure self-collision exclusion for adjacent links"}),"\n",(0,l.jsx)(e.li,{children:"Compare simulation performance with different collision geometries"}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>r});var o=i(6540);const l={},s=o.createContext(l);function t(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:t(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);