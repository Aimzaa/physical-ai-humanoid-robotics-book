"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[272],{7743:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-4-vision-language-action/chapter-4-4-ros2-action-execution","title":"ROS 2 Action Execution","description":"Goal","source":"@site/docs/module-4-vision-language-action/chapter-4-4-ros2-action-execution.md","sourceDirName":"module-4-vision-language-action","slug":"/module-4-vision-language-action/chapter-4-4-ros2-action-execution","permalink":"/physical-ai-humanoid-robotics-book/docs/module-4-vision-language-action/chapter-4-4-ros2-action-execution","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/physical-ai-humanoid-robotics-book/tree/main/docs/module-4-vision-language-action/chapter-4-4-ros2-action-execution.md","tags":[],"version":"current","frontMatter":{"id":"chapter-4-4-ros2-action-execution","title":"ROS 2 Action Execution","sidebar_label":"ROS 2 Action Execution"},"sidebar":"book","previous":{"title":"LLM Cognitive Planning","permalink":"/physical-ai-humanoid-robotics-book/docs/module-4-vision-language-action/chapter-4-3-llm-cognitive-planning"},"next":{"title":"Multimodal Robotics Integration","permalink":"/physical-ai-humanoid-robotics-book/docs/module-4-vision-language-action/chapter-4-5-multimodal-robotics"}}');var s=a(4848),i=a(8453);const l={id:"chapter-4-4-ros2-action-execution",title:"ROS 2 Action Execution",sidebar_label:"ROS 2 Action Execution"},o="ROS 2 Action Execution",r={},c=[{value:"Goal",id:"goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Step-by-Step Breakdown",id:"step-by-step-breakdown",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Diagrams",id:"diagrams",level:2},{value:"Case Study",id:"case-study",level:2},{value:"References",id:"references",level:2},{value:"Review Questions",id:"review-questions",level:2},{value:"Practical Exercises",id:"practical-exercises",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"ros-2-action-execution",children:"ROS 2 Action Execution"})}),"\n",(0,s.jsx)(n.h2,{id:"goal",children:"Goal"}),"\n",(0,s.jsx)(n.p,{children:"Implement robust action execution systems for humanoid robots using ROS 2 actions, enabling reliable task completion with feedback, cancellation, and goal management capabilities."}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Understand ROS 2 action architecture and message types"}),"\n",(0,s.jsx)(n.li,{children:"Implement action servers for humanoid robot capabilities"}),"\n",(0,s.jsx)(n.li,{children:"Create action clients for task execution"}),"\n",(0,s.jsx)(n.li,{children:"Handle action feedback and result reporting"}),"\n",(0,s.jsx)(n.li,{children:"Implement action-based navigation and manipulation"}),"\n",(0,s.jsx)(n.li,{children:"Design action execution monitoring and recovery systems"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 actions provide a powerful framework for executing long-running tasks with built-in feedback, goal management, and cancellation capabilities. For humanoid robots, actions are essential for implementing complex behaviors like walking, manipulation, navigation, and other tasks that take time to complete and require monitoring. Unlike simple topics or services, actions allow for continuous feedback during execution and the ability to cancel or preempt tasks, making them ideal for the complex, multi-step behaviors required by humanoid robots."}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action Server"}),": Node that executes action goals and provides feedback"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action Client"}),": Node that sends action goals and receives feedback"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Goal"}),": Request to perform a specific task"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Feedback"}),": Continuous status updates during execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Final outcome of action execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Preemption"}),": Canceling current goal for new one"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Goal Handles"}),": Managing active action goals"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"step-by-step-breakdown",children:"Step-by-Step Breakdown"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Action Message Definition"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define custom action message types"}),"\n",(0,s.jsx)(n.li,{children:"Specify goal, feedback, and result structures"}),"\n",(0,s.jsx)(n.li,{children:"Generate action message files"}),"\n",(0,s.jsx)(n.li,{children:"Validate message definitions"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Action Server Implementation"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create action server nodes for robot capabilities"}),"\n",(0,s.jsx)(n.li,{children:"Implement goal acceptance/rejection logic"}),"\n",(0,s.jsx)(n.li,{children:"Handle action execution with feedback"}),"\n",(0,s.jsx)(n.li,{children:"Manage goal preemption and cancellation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Action Client Development"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create action clients for task execution"}),"\n",(0,s.jsx)(n.li,{children:"Implement goal sending and monitoring"}),"\n",(0,s.jsx)(n.li,{children:"Handle feedback and result processing"}),"\n",(0,s.jsx)(n.li,{children:"Implement timeout and error handling"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Humanoid-Specific Actions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement walking and locomotion actions"}),"\n",(0,s.jsx)(n.li,{children:"Create manipulation and grasping actions"}),"\n",(0,s.jsx)(n.li,{children:"Design navigation actions for humanoid kinematics"}),"\n",(0,s.jsx)(n.li,{children:"Configure balance and stability actions"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Action Execution Monitoring"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Monitor action progress and status"}),"\n",(0,s.jsx)(n.li,{children:"Implement recovery behaviors for failures"}),"\n",(0,s.jsx)(n.li,{children:"Handle action timeouts and errors"}),"\n",(0,s.jsx)(n.li,{children:"Log action execution for debugging"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Integration with Planning Systems"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Connect action execution to planning systems"}),"\n",(0,s.jsx)(n.li,{children:"Implement action-based task scheduling"}),"\n",(0,s.jsx)(n.li,{children:"Handle multi-action coordination"}),"\n",(0,s.jsx)(n.li,{children:"Validate action execution success"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Example ROS 2 action execution for humanoid robot\nimport rclpy\nfrom rclpy.action import ActionServer, ActionClient\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\nfrom geometry_msgs.msg import Pose, Point, Twist\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import String, Float64MultiArray\nimport time\nimport threading\nfrom typing import Optional\nfrom rclpy.action.server import ServerGoalHandle\nfrom rclpy.action.client import ClientGoalHandle\nfrom rclpy.duration import Duration\n\n# Import custom action messages (these would be defined in your package)\n# For this example, we\'ll define them inline as they would typically be in .action files\n\n# Since we can\'t import custom actions, we\'ll use a simulated approach\n# In a real implementation, these would be generated from .action files\nfrom rclpy.action import Action\nfrom rclpy.action.goal_status import GoalStatus\n\nclass HumanoidWalkGoal:\n    def __init__(self):\n        self.target_pose = Pose()\n        self.speed = 0.5\n        self.enable_balance = True\n\nclass HumanoidWalkFeedback:\n    def __init__(self):\n        self.current_pose = Pose()\n        self.progress = 0.0\n        self.status = "walking"\n        self.balance_stable = True\n\nclass HumanoidWalkResult:\n    def __init__(self):\n        self.success = False\n        self.error_message = ""\n        self.final_pose = Pose()\n\nclass HumanoidWalkAction:\n    """Simulated action class for humanoid walking"""\n    Goal = HumanoidWalkGoal\n    Feedback = HumanoidWalkFeedback\n    Result = HumanoidWalkResult\n\nclass HumanoidManipulationGoal:\n    def __init__(self):\n        self.object_id = ""\n        self.target_pose = Pose()\n        self.grasp_type = "precision"\n        self.force_limit = 50.0\n\nclass HumanoidManipulationFeedback:\n    def __init__(self):\n        self.current_pose = Pose()\n        self.progress = 0.0\n        self.status = "moving"\n        self.gripper_position = 0.0\n\nclass HumanoidManipulationResult:\n    def __init__(self):\n        self.success = False\n        self.error_message = ""\n        self.object_grasped = False\n\nclass HumanoidManipulationAction:\n    """Simulated action class for humanoid manipulation"""\n    Goal = HumanoidManipulationGoal\n    Feedback = HumanoidManipulationFeedback\n    Result = HumanoidManipulationResult\n\nclass HumanoidWalkActionServer(Node):\n    """Action server for humanoid walking behavior"""\n\n    def __init__(self):\n        super().__init__(\'humanoid_walk_action_server\')\n\n        # Create action server with reentrant callback group for concurrent goals\n        self._action_server = ActionServer(\n            self,\n            HumanoidWalkAction,\n            \'humanoid_walk\',\n            execute_callback=self.execute_callback,\n            callback_group=ReentrantCallbackGroup(),\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n        # Robot state publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.joint_state_pub = self.create_publisher(JointState, \'/joint_states\', 10)\n        self.status_pub = self.create_publisher(String, \'/robot/status\', 10)\n\n        # Robot state\n        self.current_pose = Pose()\n        self.is_walking = False\n        self.current_goal_handle = None\n\n        self.get_logger().info(\'Humanoid Walk Action Server initialized\')\n\n    def goal_callback(self, goal_request):\n        """Accept or reject goal requests"""\n        self.get_logger().info(f\'Received walk goal: {goal_request.target_pose}\')\n\n        # Check if goal is valid (e.g., target is reachable)\n        if self.is_target_reachable(goal_request.target_pose):\n            return rclpy.action.server.GoalResponse.ACCEPT\n        else:\n            self.get_logger().warn(\'Goal is not reachable\')\n            return rclpy.action.server.GoalResponse.REJECT\n\n    def cancel_callback(self, goal_handle):\n        """Handle goal cancellation"""\n        self.get_logger().info(\'Received cancel request\')\n        return rclpy.action.CancelResponse.ACCEPT\n\n    def is_target_reachable(self, target_pose):\n        """Check if target pose is reachable"""\n        # In real implementation, this would check navigation maps, kinematics, etc.\n        return True\n\n    def execute_callback(self, goal_handle: ServerGoalHandle):\n        """Execute the walking action"""\n        self.get_logger().info(\'Executing walk action...\')\n\n        # Store goal handle\n        self.current_goal_handle = goal_handle\n\n        # Get goal parameters\n        target_pose = goal_handle.request.target_pose\n        speed = goal_handle.request.speed\n        enable_balance = goal_handle.request.enable_balance\n\n        # Initialize feedback\n        feedback_msg = HumanoidWalkFeedback()\n        result = HumanoidWalkResult()\n\n        try:\n            # Execute walking behavior\n            success = self.perform_walking(target_pose, speed, enable_balance, goal_handle)\n\n            if success:\n                result.success = True\n                result.final_pose = self.current_pose\n                goal_handle.succeed()\n                self.get_logger().info(\'Walk action completed successfully\')\n            else:\n                result.success = False\n                result.error_message = "Failed to reach target pose"\n                goal_handle.abort()\n                self.get_logger().info(\'Walk action failed\')\n\n        except Exception as e:\n            result.success = False\n            result.error_message = str(e)\n            goal_handle.abort()\n            self.get_logger().error(f\'Walk action exception: {e}\')\n\n        # Publish final status\n        status_msg = String()\n        status_msg.data = "walk_completed" if result.success else "walk_failed"\n        self.status_pub.publish(status_msg)\n\n        return result\n\n    def perform_walking(self, target_pose, speed, enable_balance, goal_handle: ServerGoalHandle):\n        """Perform the actual walking behavior"""\n        # Calculate distance to target\n        dx = target_pose.position.x - self.current_pose.position.x\n        dy = target_pose.position.y - self.current_pose.position.y\n        distance = (dx*dx + dy*dy)**0.5\n\n        # Simulate walking progress\n        steps = int(distance / 0.1)  # 10cm per step simulation\n        for i in range(steps):\n            # Check if goal was cancelled\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info(\'Walk action cancelled\')\n                return False\n\n            # Update progress\n            progress = (i + 1) / steps\n            self.current_pose.position.x += dx / steps\n            self.current_pose.position.y += dy / steps\n\n            # Create and publish feedback\n            feedback_msg = HumanoidWalkFeedback()\n            feedback_msg.current_pose = self.current_pose\n            feedback_msg.progress = progress\n            feedback_msg.status = "walking"\n            feedback_msg.balance_stable = True  # Simulated\n\n            goal_handle.publish_feedback(feedback_msg)\n\n            # Publish velocity command\n            cmd_vel = Twist()\n            cmd_vel.linear.x = speed if progress < 0.95 else speed * 0.5  # Slow down near target\n            self.cmd_vel_pub.publish(cmd_vel)\n\n            # Sleep to simulate walking time\n            time.sleep(0.1)\n\n            # Check for obstacles or other issues\n            if self.detect_obstacles():\n                self.get_logger().warn(\'Obstacle detected during walking\')\n                return False\n\n        # Final position adjustment\n        self.current_pose.position.x = target_pose.position.x\n        self.current_pose.position.y = target_pose.position.y\n        self.current_pose.orientation = target_pose.orientation\n\n        # Stop robot\n        stop_cmd = Twist()\n        self.cmd_vel_pub.publish(stop_cmd)\n\n        return True\n\n    def detect_obstacles(self):\n        """Detect obstacles during walking (simulated)"""\n        # In real implementation, this would check sensor data\n        import random\n        return random.random() < 0.01  # 1% chance of obstacle\n\nclass HumanoidManipulationActionServer(Node):\n    """Action server for humanoid manipulation behavior"""\n\n    def __init__(self):\n        super().__init__(\'humanoid_manipulation_action_server\')\n\n        # Create action server\n        self._action_server = ActionServer(\n            self,\n            HumanoidManipulationAction,\n            \'humanoid_manipulation\',\n            execute_callback=self.execute_callback,\n            callback_group=ReentrantCallbackGroup(),\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n        # Publishers for manipulation\n        self.joint_cmd_pub = self.create_publisher(Float64MultiArray, \'/joint_group_position_controller/commands\', 10)\n        self.status_pub = self.create_publisher(String, \'/manipulation/status\', 10)\n\n        # Robot state\n        self.current_joint_positions = [0.0] * 12  # Simulated joint positions\n        self.current_goal_handle = None\n\n        self.get_logger().info(\'Humanoid Manipulation Action Server initialized\')\n\n    def goal_callback(self, goal_request):\n        """Accept or reject manipulation goals"""\n        self.get_logger().info(f\'Received manipulation goal: {goal_request.object_id}\')\n\n        # Check if object exists and is reachable\n        if self.is_object_reachable(goal_request.object_id, goal_request.target_pose):\n            return rclpy.action.server.GoalResponse.ACCEPT\n        else:\n            self.get_logger().warn(\'Object not reachable\')\n            return rclpy.action.server.GoalResponse.REJECT\n\n    def cancel_callback(self, goal_handle):\n        """Handle manipulation goal cancellation"""\n        self.get_logger().info(\'Received manipulation cancel request\')\n        return rclpy.action.CancelResponse.ACCEPT\n\n    def is_object_reachable(self, object_id, target_pose):\n        """Check if object is reachable for manipulation"""\n        # In real implementation, this would check kinematics and collision\n        return True\n\n    def execute_callback(self, goal_handle: ServerGoalHandle):\n        """Execute the manipulation action"""\n        self.get_logger().info(f\'Executing manipulation action for object: {goal_handle.request.object_id}\')\n\n        # Store goal handle\n        self.current_goal_handle = goal_handle\n\n        # Get goal parameters\n        object_id = goal_handle.request.object_id\n        target_pose = goal_handle.request.target_pose\n        grasp_type = goal_handle.request.grasp_type\n        force_limit = goal_handle.request.force_limit\n\n        # Initialize result\n        result = HumanoidManipulationResult()\n        feedback_msg = HumanoidManipulationFeedback()\n\n        try:\n            # Execute manipulation behavior\n            success = self.perform_manipulation(object_id, target_pose, grasp_type, force_limit, goal_handle)\n\n            if success:\n                result.success = True\n                result.object_grasped = True\n                goal_handle.succeed()\n                self.get_logger().info(\'Manipulation action completed successfully\')\n            else:\n                result.success = False\n                result.error_message = "Failed to manipulate object"\n                goal_handle.abort()\n                self.get_logger().info(\'Manipulation action failed\')\n\n        except Exception as e:\n            result.success = False\n            result.error_message = str(e)\n            goal_handle.abort()\n            self.get_logger().error(f\'Manipulation action exception: {e}\')\n\n        # Publish final status\n        status_msg = String()\n        status_msg.data = "manipulation_completed" if result.success else "manipulation_failed"\n        self.status_pub.publish(status_msg)\n\n        return result\n\n    def perform_manipulation(self, object_id, target_pose, grasp_type, force_limit, goal_handle: ServerGoalHandle):\n        """Perform the actual manipulation behavior"""\n        # Simulate manipulation steps\n        steps = 100\n        for i in range(steps):\n            # Check if goal was cancelled\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info(\'Manipulation action cancelled\')\n                return False\n\n            # Update progress\n            progress = (i + 1) / steps\n            feedback_msg = HumanoidManipulationFeedback()\n            feedback_msg.progress = progress\n            feedback_msg.status = "moving_to_object" if progress < 0.3 else ("grasping" if progress < 0.7 else "moving_to_target")\n            feedback_msg.gripper_position = progress if grasp_type == "precision" else progress * 0.8\n\n            goal_handle.publish_feedback(feedback_msg)\n\n            # Update joint positions to simulate movement\n            for j in range(len(self.current_joint_positions)):\n                self.current_joint_positions[j] += (0.1 / len(self.current_joint_positions))\n\n            # Publish joint commands\n            joint_cmd = Float64MultiArray()\n            joint_cmd.data = self.current_joint_positions\n            self.joint_cmd_pub.publish(joint_cmd)\n\n            # Sleep to simulate manipulation time\n            time.sleep(0.05)\n\n        return True\n\nclass ActionExecutionClient(Node):\n    """Action client for executing humanoid actions"""\n\n    def __init__(self):\n        super().__init__(\'action_execution_client\')\n\n        # Create action clients\n        self.walk_client = ActionClient(self, HumanoidWalkAction, \'humanoid_walk\')\n        self.manipulation_client = ActionClient(self, HumanoidManipulationAction, \'humanoid_manipulation\')\n\n        # Publishers for command interface\n        self.command_sub = self.create_subscription(\n            String, \'/action/command\', self.command_callback, 10\n        )\n\n        # Publishers for results\n        self.result_pub = self.create_publisher(String, \'/action/result\', 10)\n        self.feedback_pub = self.create_publisher(String, \'/action/feedback\', 10)\n\n        self.get_logger().info(\'Action Execution Client initialized\')\n\n    def command_callback(self, msg: String):\n        """Process action commands"""\n        command = msg.data.strip()\n        self.get_logger().info(f\'Received action command: {command}\')\n\n        # Parse command and execute appropriate action\n        if command.startswith(\'walk_to \'):\n            # Extract target coordinates from command like "walk_to 1.0 2.0 0.0"\n            try:\n                parts = command.split()\n                x, y, z = float(parts[1]), float(parts[2]), float(parts[3])\n\n                target_pose = Pose()\n                target_pose.position.x = x\n                target_pose.position.y = y\n                target_pose.position.z = z\n\n                self.send_walk_goal(target_pose)\n            except (ValueError, IndexError):\n                self.get_logger().error(f\'Invalid walk command format: {command}\')\n\n        elif command.startswith(\'grasp_object \'):\n            # Extract object ID from command like "grasp_object cup_1"\n            try:\n                object_id = command.split(\' \', 1)[1]\n                self.send_manipulation_goal(object_id)\n            except IndexError:\n                self.get_logger().error(f\'Invalid manipulation command format: {command}\')\n\n    def send_walk_goal(self, target_pose: Pose):\n        """Send walk action goal"""\n        # Wait for action server\n        if not self.walk_client.wait_for_server(timeout_sec=5.0):\n            self.get_logger().error(\'Walk action server not available\')\n            return\n\n        # Create goal\n        goal_msg = HumanoidWalkAction.Goal()\n        goal_msg.target_pose = target_pose\n        goal_msg.speed = 0.3\n        goal_msg.enable_balance = True\n\n        # Send goal\n        self.get_logger().info(f\'Sending walk goal to ({target_pose.position.x}, {target_pose.position.y})\')\n\n        self._send_goal_future = self.walk_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.walk_feedback_callback\n        )\n\n        self._send_goal_future.add_done_callback(self.walk_goal_response_callback)\n\n    def send_manipulation_goal(self, object_id: str):\n        """Send manipulation action goal"""\n        # Wait for action server\n        if not self.manipulation_client.wait_for_server(timeout_sec=5.0):\n            self.get_logger().error(\'Manipulation action server not available\')\n            return\n\n        # Create goal\n        goal_msg = HumanoidManipulationAction.Goal()\n        goal_msg.object_id = object_id\n        goal_msg.target_pose = Pose()  # Default pose\n        goal_msg.grasp_type = "precision"\n        goal_msg.force_limit = 50.0\n\n        # Send goal\n        self.get_logger().info(f\'Sending manipulation goal for object: {object_id}\')\n\n        self._send_manipulation_goal_future = self.manipulation_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.manipulation_feedback_callback\n        )\n\n        self._send_manipulation_goal_future.add_done_callback(self.manipulation_goal_response_callback)\n\n    def walk_feedback_callback(self, feedback_msg):\n        """Handle walk action feedback"""\n        self.get_logger().debug(f\'Walk progress: {feedback_msg.progress:.2f}\')\n\n        # Publish feedback\n        feedback_status = String()\n        feedback_status.data = f\'walk_progress:{feedback_msg.progress:.2f}\'\n        self.feedback_pub.publish(feedback_status)\n\n    def manipulation_feedback_callback(self, feedback_msg):\n        """Handle manipulation action feedback"""\n        self.get_logger().debug(f\'Manipulation progress: {feedback_msg.progress:.2f}\')\n\n        # Publish feedback\n        feedback_status = String()\n        feedback_status.data = f\'manipulation_progress:{feedback_msg.progress:.2f}\'\n        self.feedback_pub.publish(feedback_status)\n\n    def walk_goal_response_callback(self, future):\n        """Handle walk goal response"""\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Walk goal rejected\')\n            return\n\n        self.get_logger().info(\'Walk goal accepted\')\n\n        # Get result\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.walk_result_callback)\n\n    def manipulation_goal_response_callback(self, future):\n        """Handle manipulation goal response"""\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Manipulation goal rejected\')\n            return\n\n        self.get_logger().info(\'Manipulation goal accepted\')\n\n        # Get result\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.manipulation_result_callback)\n\n    def walk_result_callback(self, future):\n        """Handle walk action result"""\n        result = future.result().result\n        self.get_logger().info(f\'Walk result: {result.success}\')\n\n        # Publish result\n        result_msg = String()\n        result_msg.data = f\'walk_result:{result.success}:{result.error_message}\'\n        self.result_pub.publish(result_msg)\n\n    def manipulation_result_callback(self, future):\n        """Handle manipulation action result"""\n        result = future.result().result\n        self.get_logger().info(f\'Manipulation result: {result.success}\')\n\n        # Publish result\n        result_msg = String()\n        result_msg.data = f\'manipulation_result:{result.success}:{result.error_message}\'\n        self.result_pub.publish(result_msg)\n\nclass ActionExecutionMonitor(Node):\n    """Monitor for action execution status and recovery"""\n\n    def __init__(self):\n        super().__init__(\'action_execution_monitor\')\n\n        # Subscribers for action status\n        self.result_sub = self.create_subscription(\n            String, \'/action/result\', self.result_callback, 10\n        )\n        self.feedback_sub = self.create_subscription(\n            String, \'/action/feedback\', self.feedback_callback, 10\n        )\n\n        # Publishers for recovery commands\n        self.recovery_pub = self.create_publisher(String, \'/action/recovery\', 10)\n\n        # Action execution tracking\n        self.action_history = []\n        self.active_actions = {}\n\n        self.get_logger().info(\'Action Execution Monitor initialized\')\n\n    def result_callback(self, msg: String):\n        """Handle action result messages"""\n        result_data = msg.data\n        self.get_logger().info(f\'Action result received: {result_data}\')\n\n        # Parse result and track in history\n        self.action_history.append({\n            \'timestamp\': self.get_clock().now().nanoseconds,\n            \'result\': result_data,\n            \'success\': \'True\' in result_data\n        })\n\n        # Check if action failed and needs recovery\n        if \'False\' in result_data:\n            self.handle_action_failure(result_data)\n\n    def feedback_callback(self, msg: String):\n        """Handle action feedback messages"""\n        feedback_data = msg.data\n        self.get_logger().debug(f\'Action feedback: {feedback_data}\')\n\n        # Update active action tracking\n        if feedback_data.startswith(\'walk_progress:\'):\n            progress = float(feedback_data.split(\':\')[1])\n            self.active_actions[\'walk\'] = progress\n        elif feedback_data.startswith(\'manipulation_progress:\'):\n            progress = float(feedback_data.split(\':\')[1])\n            self.active_actions[\'manipulation\'] = progress\n\n    def handle_action_failure(self, result_data: str):\n        """Handle action failure and trigger recovery"""\n        self.get_logger().warn(f\'Action failed: {result_data}\')\n\n        # Determine appropriate recovery action\n        recovery_action = self.determine_recovery_action(result_data)\n\n        if recovery_action:\n            recovery_msg = String()\n            recovery_msg.data = recovery_action\n            self.recovery_pub.publish(recovery_msg)\n\n            self.get_logger().info(f\'Sent recovery action: {recovery_action}\')\n\n    def determine_recovery_action(self, failure_info: str) -> Optional[str]:\n        """Determine appropriate recovery action based on failure"""\n        if \'obstacle\' in failure_info.lower():\n            return \'navigate_around_obstacle\'\n        elif \'timeout\' in failure_info.lower():\n            return \'retry_action\'\n        elif \'collision\' in failure_info.lower():\n            return \'move_to_safe_position\'\n        else:\n            return \'abort_task\'\n\ndef main(args=None):\n    """Main function for action execution system"""\n    rclpy.init(args=args)\n\n    # Create nodes\n    walk_server = HumanoidWalkActionServer()\n    manipulation_server = HumanoidManipulationActionServer()\n    action_client = ActionExecutionClient()\n    monitor = ActionExecutionMonitor()\n\n    try:\n        # Run nodes with multi-threaded executor to handle concurrent actions\n        executor = MultiThreadedExecutor()\n        executor.add_node(walk_server)\n        executor.add_node(manipulation_server)\n        executor.add_node(action_client)\n        executor.add_node(monitor)\n\n        executor.spin()\n\n    except KeyboardInterrupt:\n        walk_server.get_logger().info(\'Shutting down action execution system\')\n    finally:\n        walk_server.destroy_node()\n        manipulation_server.destroy_node()\n        action_client.destroy_node()\n        monitor.destroy_node()\n        rclpy.shutdown()\n\n# Example of using actions in a behavior tree or task planner\nclass ActionBasedTaskPlanner(Node):\n    """Task planner using ROS 2 actions"""\n\n    def __init__(self):\n        super().__init__(\'action_based_task_planner\')\n\n        # Action clients for different capabilities\n        self.walk_client = ActionClient(self, HumanoidWalkAction, \'humanoid_walk\')\n        self.manipulation_client = ActionClient(self, HumanoidManipulationAction, \'humanoid_manipulation\')\n\n        # Task queue\n        self.task_queue = []\n        self.current_task_index = 0\n\n        # Timer for task execution\n        self.task_timer = self.create_timer(1.0, self.execute_next_task)\n\n        self.get_logger().info(\'Action-Based Task Planner initialized\')\n\n    def add_task(self, task_type: str, parameters: dict):\n        """Add task to execution queue"""\n        task = {\n            \'type\': task_type,\n            \'parameters\': parameters,\n            \'completed\': False\n        }\n        self.task_queue.append(task)\n        self.get_logger().info(f\'Added task: {task_type} to queue\')\n\n    def execute_next_task(self):\n        """Execute the next task in the queue"""\n        if self.current_task_index >= len(self.task_queue):\n            self.get_logger().info(\'All tasks completed\')\n            return\n\n        current_task = self.task_queue[self.current_task_index]\n        if not current_task[\'completed\']:\n            self.execute_task(current_task)\n            self.current_task_index += 1\n\n    def execute_task(self, task: dict):\n        """Execute a single task using appropriate action"""\n        task_type = task[\'type\']\n        parameters = task[\'parameters\']\n\n        if task_type == \'walk\':\n            self.execute_walk_task(parameters)\n        elif task_type == \'manipulate\':\n            self.execute_manipulation_task(parameters)\n        else:\n            self.get_logger().warn(f\'Unknown task type: {task_type}\')\n\n    def execute_walk_task(self, params: dict):\n        """Execute walk task"""\n        target_pose = params.get(\'target_pose\', Pose())\n        speed = params.get(\'speed\', 0.5)\n\n        if self.walk_client.wait_for_server(timeout_sec=1.0):\n            goal_msg = HumanoidWalkAction.Goal()\n            goal_msg.target_pose = target_pose\n            goal_msg.speed = speed\n            goal_msg.enable_balance = True\n\n            self.walk_client.send_goal_async(goal_msg)\n            self.get_logger().info(f\'Walk task sent to ({target_pose.position.x}, {target_pose.position.y})\')\n        else:\n            self.get_logger().error(\'Walk action server not available\')\n\n    def execute_manipulation_task(self, params: dict):\n        """Execute manipulation task"""\n        object_id = params.get(\'object_id\', \'\')\n        grasp_type = params.get(\'grasp_type\', \'precision\')\n\n        if self.manipulation_client.wait_for_server(timeout_sec=1.0):\n            goal_msg = HumanoidManipulationAction.Goal()\n            goal_msg.object_id = object_id\n            goal_msg.grasp_type = grasp_type\n\n            self.manipulation_client.send_goal_async(goal_msg)\n            self.get_logger().info(f\'Manipulation task sent for object: {object_id}\')\n        else:\n            self.get_logger().error(\'Manipulation action server not available\')\n'})}),"\n",(0,s.jsx)(n.h2,{id:"diagrams",children:"Diagrams"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ROS 2 Action Architecture:\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Action         \u2502    \u2502  Action         \u2502    \u2502  Action         \u2502\n\u2502  Client         \u2502\u25c4\u2500\u2500\u25ba\u2502  Communication  \u2502\u25c4\u2500\u2500\u25ba\u2502  Server         \u2502\n\u2502  (Goal Sender)   \u2502    \u2502  (ROS 2)       \u2502    \u2502  (Goal Executor) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u25bc                       \u25bc                       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Goal Request   \u2502    \u2502  Goal, Feedback \u2502    \u2502  Goal Execution \u2502\n\u2502  (Command)      \u2502    \u2502  Messages       \u2502    \u2502  (Robot Control)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAction Execution Flow:\n\nClient Sends Goal \u2500\u2500\u25ba Server Accepts Goal \u2500\u2500\u25ba Execute Action \u2500\u2500\u25ba Send Feedback\n                    (Goal Handle Created)    (Long-running      (Progress Updates)\n                                             Task)\n\nAction States:\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PENDING    \u2502\u2500\u2500\u2500\u25ba\u2502  ACTIVE     \u2502\u2500\u2500\u2500\u25ba\u2502  SUCCEEDED  \u2502    \u2502  ABORTED    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502                     \u2502\n                        \u25bc                     \u25bc\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502  CANCELLED  \u2502    \u2502  REJECTED   \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nHumanoid Task Sequence:\n\nWalk Action \u2500\u2500\u25ba Manipulation Action \u2500\u2500\u25ba Walk Action \u2500\u2500\u25ba Speak Action\n(Single Goal)   (Single Goal)        (Single Goal)   (Single Goal)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"case-study",children:"Case Study"}),"\n",(0,s.jsx)(n.p,{children:'The ROS 2 navigation stack (Nav2) extensively uses actions for robot navigation tasks. When a robot receives a navigation goal, the navigation system creates an action that provides continuous feedback about the robot\'s progress, allows for goal preemption if a new goal is received, and reports the final result when the navigation is complete. This approach has proven highly effective for humanoid robots as well, where complex multi-step behaviors like "walk to the kitchen, pick up the cup, and bring it to the table" can be broken down into a sequence of actions that provide feedback and can be monitored and adjusted during execution.'}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/Tutorials/Beginner-Client-Libraries/Using-Actions-In-ROS2.html",children:"ROS 2 Actions Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/Tutorials/Intermediate/Writing-an-Action-Server-Client/Python.html",children:"Action Server and Client Tutorial"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://design.ros2.org/articles/actions.html",children:"ROS 2 Action Design Patterns"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"What are the key differences between ROS 2 actions, topics, and services?"}),"\n",(0,s.jsx)(n.li,{children:"How do actions enable better task management for humanoid robots?"}),"\n",(0,s.jsx)(n.li,{children:"What are the benefits of using actions for long-running robot behaviors?"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"practical-exercises",children:"Practical Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Implement a simple action server for a basic robot movement"}),"\n",(0,s.jsx)(n.li,{children:"Create an action client that sends goals and monitors progress"}),"\n",(0,s.jsx)(n.li,{children:"Test action preemption by sending new goals during execution"}),"\n",(0,s.jsx)(n.li,{children:"Implement error handling and recovery in action execution"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>l,x:()=>o});var t=a(6540);const s={},i=t.createContext(s);function l(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);